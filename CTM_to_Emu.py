# -*- coding: utf-8 -*-
import argparse
import json
import os.path
import shutil
import sys
from collections import OrderedDict

from tqdm import tqdm

import ID
import Transcriber
from CTM import CTM
from Config import get_config
from R_process import compute
from Syllables import Syllables
from Wave import extract_audio

parser = argparse.ArgumentParser(description='Program to convert CTM files (usually generated by Kaldi) into a folder '
                                             'structure used by EMU-SDMS')

parser.add_argument('out_dir', help='Output directory')
parser.add_argument('words_ctm', help='CTM containing words')
parser.add_argument('phones_ctm', help='CTM contatinng phonemes')
parser.add_argument('wav',
                    help='Wave file corresponging to CTMs (only if single file, use --wav-scp for multiple files)',
                    default=None, nargs='?')
parser.add_argument('--wav-scp',
                    help='List of WAV files if CTM contains references to multiple files. Uses Kaldi wav.scp format.',
                    default=None)
parser.add_argument('--utt2ses', help='List of utterance to session mappings (similar to utt2spk).', default=None)
parser.add_argument('-o', '--overwrite', help='Overwrite output directory.', action='store_true')
parser.add_argument('-n', '--name', help='Name of the database.', default='database')
parser.add_argument('-r', '--rate', help='Samplerate of WAV file', default=16000.0, type=float)
parser.add_argument('--rm-besi', help='Remove _B,_E,_S,_I from phonemes', type=bool)
parser.add_argument('--transcriber', help='Path to the transcriber program.', default='/home/guest/apps/transcriber')
parser.add_argument('--feat',
                    help='Compute extra features (comma separated) using R package "wrassp", e.g.: forest, ksvF0, mhsF0, rmsana, zcrana')
parser.add_argument('-s', '--symlink', help='Use symlinks instead of copying audio to database', action='store_true')
parser.add_argument('--segs', help='Use segments file')
parser.add_argument('--split', help='Split long file into segments at least this meany seconds long.')

args = parser.parse_args()

if args.split:
    print('Split is not yet implemented!')
    sys.exit(-1)

out_path = os.path.abspath(args.out_dir)

Transcriber.transcriber_path = args.transcriber

if os.path.exists(out_path):
    if args.overwrite:
        print('Overwriting dir: {}'.format(out_path))
        shutil.rmtree(args.out_dir)
    else:
        print('Output dir {} already exists!'.format(out_path))
        print('Exiting! (see help for overwrite option)')
        sys.exit(0)

os.mkdir(out_path)

config = get_config(args.name, args.feat.split(','))
with open('{}/{}_DBconfig.json'.format(out_path, args.name), 'w') as f:
    json.dump(config, f, indent=4)

wav_scp = {}
utt2ses = {}

if args.wav:

    wav_path = os.path.abspath(args.wav)
    wav_name = os.path.basename(wav_path)
    utt_name = wav_name[:-4]
    wav_scp[utt_name] = wav_path

else:
    print('Loading wav.scp...')

    with open(args.wav_scp) as f:
        for line in f:
            p = line.find(' ')
            name = line[:p].strip()
            path = line[p + 1:].strip()
            wav_scp[name] = path

    if args.utt2ses:
        print('Loading utt2ses...')
        with open(args.utt2ses) as f:
            for line in f:
                p = line.find(' ')
                utt = line[:p].strip()
                ses = line[p + 1:].strip()
                utt2ses[utt] = ses

segs = None
if args.segs:
    print('Loading segments...')
    with open(args.segs) as f:
        segs = {}
        for line in f:
            tok = line[:-1].strip().split(' ')
            assert len(tok) == 4, 'Segments line is not exactly 4 tokens: {}'.format(line)
            segs[tok[0]] = (tok[1], tok[2], tok[3])

print('Loading words ctm...')
words = CTM()
words.load(args.words_ctm)
print('Loading phones ctm...')
phonemes = CTM()
phonemes.load(args.phones_ctm)

for words_name, words_file in tqdm(iter(words.files.items()), total=len(list(words.files.items()))):

    ID.reset()

    ses_name = 'default'
    if words_name in utt2ses:
        ses_name = utt2ses[words_name]
    if not os.path.exists('{}/{}_ses'.format(out_path, ses_name)):
        os.mkdir('{}/{}_ses'.format(out_path, ses_name))

    file_path = out_path + '/{}_ses/{}_bndl'.format(ses_name, words_name)
    os.mkdir(file_path)

    if segs:
        seg = segs[words_name]
        seg_start = float(seg[1])
        seg_end = float(seg[2])
        wav_path = wav_scp[seg[0]]

        dest_wav = '{}/{}.wav'.format(file_path, words_name)
        extract_audio(wav_path, seg_start, seg_end, dest_wav)

    else:
        wav_path = wav_scp[words_name]

        dest_wav = '{}/{}.wav'.format(file_path, words_name)
        if args.symlink:
            os.symlink(wav_path, dest_wav)
        else:
            shutil.copy(wav_path, dest_wav)

    phonemes_file = phonemes.files[words_name]

    utterance = words_file.getUttFile()

    annot = OrderedDict()

    annot['name'] = words_name
    annot['annotates'] = words_name + '.wav'
    annot['sampleRate'] = args.rate

    levels = []
    annot['levels'] = levels

    levels.append(utterance.getAnnotation('Utterance', 'Utterance', get_segments=False))

    levels.append(words_file.getAnnotation('Word', 'Word', args.rate))

    syllables = Syllables(words_file, phonemes_file)
    levels.append(syllables.getWordAnnotation('Syllable', 'Syllable', 'Stress'))
    levels.append(syllables.getPhonemeAnnotation('Phonetic Syllable', 'Syllable', 'Stress'))

    if args.rm_besi:
        levels.append(phonemes_file.getAnnotation('Phoneme', 'Phoneme', args.rate, rmbesi=True))
    else:
        levels.append(phonemes_file.getAnnotation('Phoneme', 'Phoneme', args.rate))

    uttlinks = utterance.getLinks(words_file)
    wordlinks = words_file.getLinks(phonemes_file)
    syllinks = syllables.getLinks()

    annot['links'] = uttlinks + syllinks

    with open('{}/{}_annot.json'.format(file_path, words_name), 'w') as f:
        json.dump(annot, f, indent=4)

    if args.feat:
        compute(dest_wav, args.feat.split(','))
