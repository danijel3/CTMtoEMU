# -*- coding: utf-8 -*-
import argparse
import json
import shutil
import sys
from collections import OrderedDict
from pathlib import Path

from tqdm import tqdm

import Transcriber
from CTM import CTM
from Config import get_config
from R_process import compute
from Syllables import Syllables
from Wave import extract_audio

parser = argparse.ArgumentParser(description='Program to convert CTM files (usually generated by Kaldi) into a folder '
                                             'structure used by EMU-SDMS')

parser.add_argument('out_dir', help='Output directory')
parser.add_argument('words_ctm', help='CTM containing words')
parser.add_argument('phones_ctm', help='CTM contacting phonemes')
parser.add_argument('wav',
                    help='Wave file corresponding to CTMs (only if single file, use --wav-scp for multiple files)',
                    default=None, nargs='?')
parser.add_argument('--wav-scp',
                    help='List of WAV files if CTM contains references to multiple files. Uses Kaldi wav.scp format.',
                    default=None)
parser.add_argument('--utt2ses', help='List of utterance to session mappings (similar to utt2spk).', default=None)
parser.add_argument('-o', '--overwrite', help='Overwrite output directory.', action='store_true')
parser.add_argument('-r', '--rate', help='Sample rate of WAV file', default=16000.0, type=float)
parser.add_argument('--phonetisaurus', help='Path to the phonetisaurus-g2pfst program.',
                    default='/home/guest/Applications/kaldi/tools/phonetisaurus-g2p/phonetisaurus-g2pfst')
parser.add_argument('--g2p-model', help='Path to the FST G2P model.',
                    default='model.fst')
parser.add_argument('--feat',
                    help='Compute extra features (comma separated) using R package "wrassp", e.g.: forest, ksvF0, '
                         'mhsF0, rmsana, zcrana')
parser.add_argument('-s', '--symlink', help='Use symlinks instead of copying audio to database', action='store_true')
parser.add_argument('--segs', help='Use segments file')
parser.add_argument('--split', help='Split long file into segments at least this meany seconds long.')

args = parser.parse_args()

if args.split:
    print('Split is not yet implemented!')
    sys.exit(-1)

out_path = Path(args.out_dir)

Transcriber.phonetisaurus_bin = Path(args.phonetisaurus)
Transcriber.model_fst = Path(args.g2p_model)

if out_path.exists():
    if args.overwrite:
        print(f'Overwriting dir: {out_path}')
        shutil.rmtree(str(out_path))
    else:
        print(f'Output dir {out_path} already exists!')
        print('Exiting! (see help for overwrite option)')
        sys.exit(0)

out_path.mkdir()

config = get_config(str(out_path.name), args.feat.split(','))
with open(str(out_path / f'{out_path.name}_DBconfig.json'), 'w') as f:
    json.dump(config, f, indent=4)

wav_scp = {}
utt2ses = {}

if args.wav:

    wav_path = Path(args.wav)
    wav_name = wav_path.name
    utt_name = wav_name[:-4]
    wav_scp[utt_name] = wav_path

else:
    print('Loading wav.scp...')

    with open(args.wav_scp) as f:
        for line in f:
            p = line.find(' ')
            name = line[:p].strip()
            path = line[p + 1:].strip()
            wav_scp[name] = path

    if args.utt2ses:
        print('Loading utt2ses...')
        with open(args.utt2ses) as f:
            for line in f:
                p = line.find(' ')
                utt = line[:p].strip()
                ses = line[p + 1:].strip()
                utt2ses[utt] = ses

segs = None
if args.segs:
    print('Loading segments...')
    with open(args.segs) as f:
        segs = {}
        for line in f:
            tok = line[:-1].strip().split(' ')
            assert len(tok) == 4, f'Segments line is not exactly 4 tokens: {line}'
            segs[tok[0]] = (tok[1], tok[2], tok[3])

print('Loading words ctm...')
words = CTM()
words.load(args.words_ctm)
print('Loading phones ctm...')
phonemes = CTM()
phonemes.load(args.phones_ctm)

for words_name, words_file in tqdm(iter(words.files.items()), total=len(list(words.files.items()))):

    ses_name = 'default'
    if words_name in utt2ses:
        ses_name = utt2ses[words_name]
    ses_path = out_path / f'{ses_name}_ses'
    if not ses_path.exists():
        ses_path.mkdir()

    file_path = out_path / f'{ses_name}_ses' / f'{words_name}_bndl'
    file_path.mkdir()

    if segs:
        seg = segs[words_name]
        seg_start = float(seg[1])
        seg_end = float(seg[2])
        wav_path = wav_scp[seg[0]]

        dest_wav = file_path / f'{words_name}.wav'
        extract_audio(wav_path, seg_start, seg_end, str(dest_wav))

    else:
        wav_path = wav_scp[words_name]

        dest_wav = file_path / f'{words_name}.wav'
        if args.symlink:
            dest_wav.symlink_to(wav_path)
        else:
            shutil.copy(wav_path, str(dest_wav))

    phonemes_file = phonemes.files[words_name]

    utterance = words_file.getUttFile()

    annot = OrderedDict()

    annot['name'] = words_name
    annot['annotates'] = words_name + '.wav'
    annot['sampleRate'] = args.rate

    levels = []
    annot['levels'] = levels

    levels.append(utterance.getAnnotation('Utterance', 'Utterance', get_segments=False))

    levels.append(words_file.getAnnotation('Word', 'Word', args.rate))

    syllables = Syllables(words_file, phonemes_file)
    levels.append(syllables.getWordAnnotation('Syllable', 'Syllable', 'Stress'))
    levels.append(syllables.getPhonemeAnnotation('Phonetic Syllable', 'Syllable', 'Stress'))

    levels.append(phonemes_file.getAnnotation('Phoneme', 'Phoneme', args.rate, phonemes=True))

    uttlinks = utterance.getLinks(words_file)
    wordlinks = words_file.getLinks(phonemes_file)
    syllinks = syllables.getLinks()

    annot['links'] = uttlinks + syllinks

    with open(str(file_path / f'{words_name}_annot.json'), 'w') as f:
        json.dump(annot, f, indent=4)

    if args.feat:
        compute(dest_wav, args.feat.split(','))
